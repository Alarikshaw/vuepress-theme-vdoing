---
title: 常见问题
date: 2021-03-18 09:11:15
permalink: /pages/c1712f/
categories:
  - HtmlCSS面试题
  - HTML篇
tags:
  - HTML
  - CSS
  - 面试题
---

## `link` 和 `@import`的区别

1. 从属关系区别。`@import` 只能导入样式表，`link` 还可以定义 `RSS`、`rel` 连接属性、引入网站图标等；
2. 加载顺序区别；加载页面时，`link` 标签引入的 `CSS` 被同时加载；`@import` 引入的 `CSS` 将在页面加载完毕后被加载；
3. 兼容性区别
4. `link`是`XHTML`标签，除了加载`CSS`外，还可以定义`RSS`等其他事务；`@import`属于`CSS`范畴，只能加载`CSS`

## 常见浏览器内核

### 内核

- `Trident`：`IE` 浏览器内核；
- `Gecko`：`Firefox` 浏览器内核；
- `Presto`：`Opera` 浏览器内核；
- `Webkit`：`Safari` 浏览器内核；
- `Blink`：谷歌浏览器内核，属于 `Webkit` 的一个分支，与 `Opera` 一起在研发

### 浏览器

- `IE：Trident`，`IE` 内核；
- `Chrome`：以前是 `Webkit`，现在是 `Blink` 内核；
- `360`、猎豹浏览器内核：`IE` + `Blink` 双内核；
- 搜狗、遨游、`QQ` 浏览器内核：`Trident`（兼容模式）+ `Webkit`（高速模式）；
- 百度浏览器、世界之窗内核：`IE` 内核；
- `2345` 浏览器：以前是 `IE` 内核，现在是 `IE` + `Blink` 双内核；
- `UC` 浏览器内核：`Webkit` + `Trident`；

## 浏览器渲染原理

![](https://picgoi-mg.oss-cn-beijing.aliyuncs.com/img/20210318093103.png)

### 工作流程

#### 浏览器会解析三个东西：

- 一个是`HTML/SVG/XHTML`，事实上，`Webkit`有三个`C++`的类对应这三类文档。解析这三种文件会产生一个`DOM Tree`；
- `CSS`，解析`CSS`会产生`CSS`规则树；
- `Javascript`，脚本，主要是通过`DOM API`和`CSSOM API`来操作`DOM Tree`和`CSS Rule Tree`；

#### 解析完成后：

> #### 浏览器引擎会通过`DOM Tree` 和 `CSS Rule Tree` 来构造 `Rendering Tree`

- `Rendering Tree` 渲染树并不等同于`DOM`树，因为一些像`Header`或`display:none`的东西就没必要放在渲染树中了。
- `CSS` 的 `Rule Tree`主要是为了完成匹配并把`CSS Rule`附加上`Rendering Tree`上的每个`Element`。也就是`DOM`结点。也就是所谓的`Frame`。
- 然后，计算每个`Frame`（也就是每个`Element`）的位置，这又叫`layout`和`reflow`过程。

#### 绘制

## 构建`DOM`

浏览器会遵守一套步骤将`HTML` 文件转换为 `DOM` 树。宏观上，可以分为几个步骤：

> 字节数据 => 字符串 => `Token` => `Node` => `DOM`

- 浏览器从磁盘或者网络读取`HTML`的原始字节，并根据指定编码(`UTF-8`)，转换成字符串。
- 将字符串转换为`Token`，如`<body><html>`等，**`Token`中会标识出当前`Token`是“开始标签”或是“结束标签”亦或是“文本”等信息**。

> 节点与节点之间的关系如何维护？
>
> 事实上，这就是`Token`要标识“起始标签”和“结束标签”等标识的作用。例如“`title`”`Token`的起始标签和结束标签之间的节点肯定是属于“`head`”的子节点。

### 生成节点对象并构建`DOM`

构建DOM的过程中，不是等所有`Token`都转换完成后再去生成节点对象，而是一边生成`Token`一边消耗`Token`来生成节点对象。

换句话说，每个`Token`被生成后，会立刻消耗这个`Token`创建出节点对象。

> **注意：带有结束标签标识的`Token`不会创建节点对象。**

## 构建`CSSOM`

`DOM`会捕获页面的内容，但浏览器还需要知道页面如何展示，所以需要构建`CSSOM`。

构建`CSSOM`的过程与构建`DOM`的过程非常相似，当浏览器接收到一段`CSS`，浏览器首先要做的是识别出`Token`，然后构建节点并生成`CSSOM`。

> 字节数据 => 字符串 => `Token` => `Node` => `CSSOM`

**注意：`CSS`匹配`HTML`元素是一个相当复杂和有性能问题的事情。**

**所以，`DOM`树要小，`CSS`尽量用`id`和`class`，千万不要过渡层叠下去**。

### 构建渲染树

当我们生成 `DOM` 树和 `CSSOM` 树以后，就需要将这两棵树组合为渲染树

在这一过程中，不是简单的将两者合并就行了。

**渲染树只会包括需要显示的节点和这些节点的样式信息**。

如果某个节点是 `display: none` 的，那么就不会在渲染树中显示。

### 布局与绘制

当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。

这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。

> 通常这一行为也被称为“自动重排”。

布局完成后，浏览器会立即发出“`Paint Setup`”和“`Paint`”事件，将渲染树转换成屏幕上的像素。

##  渲染过程中遇到`JS`文件如何处理？

`JavaScript`的加载、解析与执行会阻塞`DOM`的构建，也就是说，在构建`DOM`时，`HTML`解析器若遇到了`JavaScript`，那么它会暂停构建`DOM`，将控制权移交给`JavaScript`引擎，等`JavaScript`引擎运行完毕，浏览器再从中断的地方恢复`DOM`构建。

也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 `JS` 文件，这也是都建议将 `script` 标签放在 `body` 标签底部的原因。当然在当下，并不是说 `script` 标签必须放在底部，因为你可以给 `script` 标签添加 `defer` 或者 `async` 属性；

:::warning

`JS`文件不只是阻塞`DOM`的构建，它会导致`CSSOM`也阻塞`DOM`的构建。

:::

原本`DOM`和`CSSOM`的构建是互不影响，井水不犯河水，但是一旦引入了`JavaScript`，`CSSOM`也开始阻塞`DOM`的构建，只有`CSSOM`构建完毕后，`DOM`再恢复`DOM`构建。

`WHY?`

这是因为`JavaScript`不只是可以改`DOM`，它还可以更改样式，也就是它可以更改`CSSOM`。

前面我们介绍，不完整的`CSSOM`是无法使用的，但`JavaScript`中想访问`CSSOM`并更改它，那么在执行`JavaScript`时，必须要能拿到完整的`CSSOM`。

所以就导致了一个现象，如果浏览器尚未完成`CSSOM`的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和`DOM`构建，直至其完成`CSSOM`的下载和构建。

也就是说，**在这种情况下，浏览器会先下载和构建`CSSOM`，然后再执行`JavaScript`，最后在继续构建`DOM`**。

## 回流和重绘

- 重绘：当`render tree`中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的，比如`background-color`。

- 回流：当`render tree`中的一部分(或全部)因为元素的规模尺寸、布局、隐藏等改变而需要重新构建

  > `reader tree => 渲染树`

**回流必定会发生重绘，重绘不一定会引发回流**。

重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。

回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。

### 常见引起回流属性和方法

> 任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发回流，

- 添加或者删除可见的`DOM`元素；
- 元素尺寸改变——边距、填充、边框、宽度和高度
- 内容变化，比如用户在`input`框中输入文字
- 浏览器窗口尺寸改变——`resize`事件发生时
- 计算 `offsetWidth` 和 `offsetHeight` 属性
- 设置 `style` 属性的值

## `async`和`defer`的作用是什么？有什么区别?

#### 情况1`<script src="script.js"></script>`

没有 `defer` 或 `async`，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。

#### 情况2`<script async src="script.js"></script>` (**异步下载**)

`async` 属性表示异步执行引入的 `JavaScript`，与 `defer` 的区别在于，如果已经加载好，就会开始执行——无论此刻是 `HTML` 解析阶段还是 `DOMContentLoaded` 触发之后。

需要注意的是，这种方式加载的 `JavaScript` 依然会阻塞 `load` 事件。换句话说，`async-script` 可能在 `DOMContentLoaded` 触发之前或之后执行，但一定在 `load` 触发之前执行。

#### 情况3 `<script defer src="script.js"></script>`(**延迟执行**)

`defer` 属性表示延迟执行引入的 `JavaScript`，即这段 `JavaScript` 加载时 `HTML` 并未停止解析，这两个过程是并行的。整个 `document` 解析完毕且 `defer-script` 也加载完成之后（这两件事情的顺序无关），会执行所有由 `defer-script` 加载的 `JavaScript` 代码，然后触发 `DOMContentLoaded` 事件。

`defer` 与相比普通 `script`，有两点区别：**载入 `JavaScript` 文件时不阻塞 `HTML` 的解析，执行阶段被放到 `HTML` 标签解析完成之后**。

在加载多个`JS`脚本的时候，`async`是无顺序的加载，而`defer`是有顺序的加载

## 为什么操作 `DOM` 慢

因为 `DOM` 是属于渲染引擎中的东西，而 `JS` 又是 `JS` 引擎中的东西。

当我们通过 `JS` 操作 `DOM` 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。

操作 `DOM` 次数一多，也就等同于一直在进行线程之间的通信，并且操作 `DOM` 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。

## 渲染页面时常见哪些不良现象？

**由于浏览器的渲染机制不同，在渲染页面时会出现两种常见的不良现象—-白屏问题和`FOUS`（无样式内容闪烁）**

* `FOUC`：由于浏览器渲染机制（比如`firefox`），再`CSS`加载之前，先呈现了`HTML`，就会导致展示出无样式内容，然后样式突然呈现的现象；

* 白屏：有些浏览器渲染机制（比如`chrome`）要先构建`DOM`树和`CSSOM`树，构建完成后再进行渲染，如果`CSS`部分放在`HTML`尾部，由于`CSS`未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把`js`文件放在头部，脚本会阻塞后面内容的呈现，脚本会阻塞其后组件的下载，出现白屏问题。

##  总结

- 浏览器工作流程：构建`DOM` -> 构建`CSSOM` -> 构建渲染树 -> 布局 -> 绘制。
- `CSSOM`会阻塞渲染，只有当`CSSOM`构建完毕后才会进入下一个阶段构建渲染树。
- 通常情况下`DOM`和`CSSOM`是并行构建的，但是当浏览器遇到一个`script`标签时，`DOM`构建将暂停，直至脚本完成执行。但由于`JavaScript`可以修改`CSSOM`，所以需要等`CSSOM`构建完毕后再执行`JS`。
- 如果你想首屏渲染的越快，就越不应该在首屏就加载 `JS` 文件，建议将 `script` 标签放在 `body` 标签底部。