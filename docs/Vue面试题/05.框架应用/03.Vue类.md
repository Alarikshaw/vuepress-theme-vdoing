---
title: Vue类
date: 2021-03-18 13:51:10
permalink: /pages/578232/
categories:
  - JavaScript面试题
  - 框架应用
tags:
  - Vue
  - 面试题
---

## 写 `React / Vue` 项目时为什么要在列表组件中写 `key`，其作用是什么？

v-for一般用在列表的渲染，渲染的时候会默认遵守就地复用策略。

就地复用策略：

```html
当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。

这种方式只适用于列表渲染不依赖子组件状态，或临时 DOM 状态变化。
```

`vue` 和 `react` 都是采用 `diff` 算法来对比新旧虚拟节点，从而更新节点。

在 `vue` 的 `diff` 函数交叉对比中，当新节点跟旧节点`头尾交叉对比`没有结果时，会根据新节点的 `key` 去对比旧节点数组中的 `key`，从而找到相应旧节点（这里对应的是一个 `key => index` 的 `map` 映射）。

如果没有找到就认为是一个新增节点。

而如果没有 `key`，那么就会采用遍历查找的方式去找到对应的旧节点。

种一个 `map` 映射，另一种是遍历查找。

相比而言，`map` 映射的速度更快。

## 为什么 `Vuex` 的 `mutation` 和 `Redux` 的 `reducer` 中不能做异步操作？

### `Mutation` 必须是同步函数

一条重要的原则就是要记住 `mutation` 必须是同步函数。为什么？请参考下面的例子

```javascript
mutations: {
  someMutation (state) {
    api.callAsyncMethod(() => {
      state.count++
    })
  }
}
```

观察 `devtool` 中的 `mutation` 日志。每一条 `mutation` 被记录，`devtools` 都需要捕捉到前一状态和后一状态的快照。

然而，在上面的例子中 `mutation` 中的异步函数中的回调让这不可能完成：因为当 `mutation` 触发的时候，回调函数还没有被调用，`devtools` 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。

#### 区分 `actions` 和 `mutations` 并不是为了解决竞态问题，而是为了能用 `devtools` 追踪状态变化。

- 事实上在 `vuex` 里面 `actions` 只是一个架构性的概念，并不是必须的，说到底只是一个函数，你在里面想干嘛都可以，只要最后触发 `mutation` 就行。
- 异步竞态怎么处理那是用户自己的事情。`vuex` 真正限制你的只有 `mutation` 必须是同步的这一点（在 `redux` 里面就好像 `reducer` 必须同步返回下一个状态一样）。
- 同步的意义在于这样每一个 `mutation` 执行完成后都可以对应到一个新的状态（和 `reducer` 一样），这样 `devtools` 就可以打个 `snapshot` 存下来，然后就可以随便 `time-travel` 了。
- 如果你开着 `devtool` 调用一个异步的 `action`，你可以清楚地看到它所调用的 `mutation` 是何时被记录下来的，并且可以立刻查看它们对应的状态。

> 在此前提下，开发者们总结出：`vuex`的处理方式是同步在`mutation`里面，异步在`actions`里面。
>
> [尤雨溪对于actions 和 mutations的区分](https://www.zhihu.com/question/48759748/answer/112823337)

## 在 `Vue` 中，子组件为何不可以修改父组件传递的 `Prop`，如果修改了，`Vue` 是如何监控到属性的修改并给出警告的。

### 子组件为何不可以修改父组件传递的 `Prop`

单向数据流，易于监测数据的流动，出现了错误可以更加迅速的定位到错误发生的位置。
如果修改了，`Vue` 是如何监控到属性的修改并给出警告的。

